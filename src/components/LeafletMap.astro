---
import type { Street } from '../data/types';

export interface Props {
  mapId: string;
  locationName: string;
  centerLat: number;
  centerLng: number;
  initialZoom: number;
  minZoom?: number;
  maxZoom?: number;
  bounds?: [[number, number], [number, number]];
  mapData: Street[];
}

const { 
  mapId, 
  locationName, 
  centerLat, 
  centerLng, 
  initialZoom, 
  minZoom = 13, 
  maxZoom = 18, 
  bounds = null, 
  mapData 
} = Astro.props;
---

<div class="map-container">
  <div id={mapId} class="map"></div>
  <div class="map-legend">
    <h4>Cambios de sentido en {locationName}</h4>
    <div class="legend-item" id="change-legend-item">
      <span class="legend-color change-direction"></span>
      <span>Cambio de sentido</span>
    </div>
    <div class="legend-item" id="doubleway-legend-item">
      <span class="legend-color double-way"></span>
      <span>Doble sentido</span>
    </div>
    <div class="legend-item" id="noparking-legend-item">
      <span class="legend-color no-parking"></span>
      <span>Prohibido estacionar</span>
    </div>
    <div class="legend-item" id="direction-legend-item">
      <span class="legend-icon">↑</span>
      <span>Dirección de circulación</span>
    </div>
  </div>
</div>

<script define:vars={{ mapId, centerLat, centerLng, initialZoom, minZoom, maxZoom, bounds, mapData }}>
  // Importar Leaflet solo en el lado del cliente
  document.addEventListener('DOMContentLoaded', async () => {
    // Cargar dinamicamente Leaflet desde CDN si no está ya cargado
    if (!window.L) {
      await new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        script.onload = resolve;
        document.head.appendChild(script);

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        document.head.appendChild(link);
      });
    }
    
    // Cargar Leaflet.PolylineDecorator para las flechas
    await new Promise((resolve) => {
      const polylineDecoratorScript = document.createElement('script');
      polylineDecoratorScript.src = 'https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js';
      polylineDecoratorScript.onload = resolve;
      document.head.appendChild(polylineDecoratorScript);
    });
    
    // Inicializar el mapa con las nuevas opciones
    const map = L.map(mapId, {
      center: [centerLat, centerLng],
      zoom: initialZoom,
      minZoom: minZoom,
      maxZoom: maxZoom,
      maxBounds: bounds ? L.latLngBounds(bounds) : null,
    });
    
    // Variables para seguimiento de tipos visibles
    let visibleTypes = {
      change: false,
      doubleway: false,
      noparking: false,
      hasArrows: false
    };
    
    // Variables para seguimiento de tipos existentes en los datos
    let existingTypes = {
      change: false,
      doubleway: false,
      noparking: false,
      hasArrows: false
    };
    
    map.on('moveend zoomend', function() {
        var center = map.getCenter();
        var zoom = map.getZoom();
        var bounds = map.getBounds();
        var southWest = bounds.getSouthWest();
        var northEast = bounds.getNorthEast();

        console.clear(); // Limpia la consola para no saturar
        console.log("--- PARÁMETROS ACTUALES ---");
        console.log(`Center: [${center.lat.toFixed(5)}, ${center.lng.toFixed(5)}]`);
        console.log(`Zoom: ${zoom}`);
        console.log(`Min/Max Bounds (Copiar esto):`);
        console.log(`[
          [${southWest.lat.toFixed(5)}, ${southWest.lng.toFixed(5)}], // SouthWest (Abajo-Izquierda)
          [${northEast.lat.toFixed(5)}, ${northEast.lng.toFixed(5)}]  // NorthEast (Arriba-Derecha)
        ]`);
        
        // Actualizar leyenda según elementos visibles
        updateLegendVisibility();
    });

    // Agregar la capa base de OpenStreetMap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 19
    }).addTo(map);
    
    // Determinar la dirección de las flechas según el tipo de cambio
    function determineDirection(direction, type) {
      if (type === 'doubleway') {
        return 'bidirectional';
      } else if (direction === 'none') {
        return 'none';
      } else {
        return direction;
      }
    }
    
    // Determinar el color según el tipo de cambio
    function getStreetColor(type) {
      switch(type) {
        case 'change': return '#1E88E5';
        case 'doubleway': return '#27ae60';
        case 'noparking': return '#e74c3c';
        default: return '#FF8A65';
      }
    }
    // Asegurarnos que mapData sea un array válido
    const streetData = Array.isArray(mapData) ? mapData : [];
    
    // Función para determinar qué tipos existen en los datos
    function checkExistingTypes() {
      // Resetear tipos existentes
      existingTypes = {
        change: false,
        doubleway: false,
        noparking: false,
        hasArrows: false
      };
      
      // Verificar qué tipos están presentes en los datos
      streetData.forEach(street => {
        if (street.type === 'change') existingTypes.change = true;
        if (street.type === 'doubleway') existingTypes.doubleway = true;
        if (street.type === 'noparking') existingTypes.noparking = true;
        
        // Verificar si hay flechas de dirección
        if (street.direction && street.direction !== 'none' && street.type !== 'doubleway') {
          existingTypes.hasArrows = true;
        }
      });
      
      console.log('Tipos existentes en los datos:', existingTypes);
    }
    
    // Función para actualizar la visibilidad de la leyenda
    function updateLegendVisibility() {
      // Resetear visibilidad
      visibleTypes = {
        change: false,
        doubleway: false,
        noparking: false,
        hasArrows: false
      };
      
      // Comprobar qué tipos de elementos están visibles en la vista actual
      const currentBounds = map.getBounds();
      
      streetData.forEach(street => {
        // Verificar si al menos un punto de la calle está en la vista actual
        for (let i = 0; i < street.coordinates.length; i++) {
          const point = L.latLng(street.coordinates[i][0], street.coordinates[i][1]);
          if (currentBounds.contains(point)) {
            // Marcar el tipo como visible
            if (street.type === 'change') visibleTypes.change = true;
            if (street.type === 'doubleway') visibleTypes.doubleway = true;
            if (street.type === 'noparking') visibleTypes.noparking = true;
            
            // Verificar si hay flechas de dirección
            if (street.direction && street.direction !== 'none' && street.type !== 'doubleway') {
              visibleTypes.hasArrows = true;
            }
            break; // Un punto es suficiente para marcar el tipo como visible
          }
        }
      });
      
      // Actualizar la visibilidad de los elementos de la leyenda
      // Solo mostrar tipos que existen en los datos Y están actualmente visibles
      document.getElementById('change-legend-item').classList.toggle('hidden', !visibleTypes.change || !existingTypes.change);
      document.getElementById('doubleway-legend-item').classList.toggle('hidden', !visibleTypes.doubleway || !existingTypes.doubleway);
      document.getElementById('noparking-legend-item').classList.toggle('hidden', !visibleTypes.noparking || !existingTypes.noparking);
      document.getElementById('direction-legend-item').classList.toggle('hidden', !visibleTypes.hasArrows || !existingTypes.hasArrows);
      
      console.log('Tipos visibles en la vista actual:', visibleTypes);
    }
    
    // Verificar qué tipos existen en el mapa
    function checkExistingTypes() {
      // Inicializar todos como falsos
      existingTypes = {
        change: false,
        doubleway: false,
        noparking: false,
        hasArrows: false
      };
      
      // Recorrer todos los datos para ver qué tipos existen
      streetData.forEach(street => {
        if (street.type === 'change') existingTypes.change = true;
        if (street.type === 'doubleway') existingTypes.doubleway = true;
        if (street.type === 'noparking') existingTypes.noparking = true;
        
        // Verificar si hay calles con flechas de dirección
        if (street.direction && street.direction !== 'none' && street.type !== 'doubleway') {
          existingTypes.hasArrows = true;
        }
      });
      
      console.log('Tipos existentes en los datos:', existingTypes);
    }
    
    // Ejecutar verificación inicial
    checkExistingTypes();
    
    // Agregar líneas para las calles con cambios
    streetData.forEach(street => {
      // Obtener el color basado en el tipo de calle
      const streetColor = getStreetColor(street.type);
      
      // Crear una capa invisible más ancha para facilitar el clic
      const clickablePath = L.polyline(street.coordinates, {
        color: 'transparent',
        weight: 12, // El doble de ancho pero invisible
        opacity: 0
      }).addTo(map);
      
      // Crear la línea visible para la calle
      const streetPath = L.polyline(street.coordinates, {
        color: streetColor,
        weight: 6,
        opacity: 0.8
      }).addTo(map);
      
      // Preparar texto para el popup con mejor descripción del sentido
      let sentidoTexto = '';
      if (street.type === 'change') {
        sentidoTexto = 'Cambió de sentido: ahora circulación en un solo sentido';
      } else if (street.type === 'doubleway') {
        sentidoTexto = 'Mantiene doble sentido de circulación';
      } else if (street.type === 'noparking') {
        sentidoTexto = 'Prohibido estacionar';
      }
      
      // Agregar popup con información mejorada a ambas capas
      const popupContent = `
        <div class="street-popup">
          <h3>${street.name}</h3>
          <p><strong>Tramo:</strong> ${street.section}</p>
          <p><strong>Sentido:</strong> ${street.newDirection}</p>
          ${street.details ? `<p>${street.details}</p>` : ''}
        </div>
      `;
      
      // Ahora usaremos el popup mejorado que crearemos más adelante
      // Primero, extraemos las calles y creamos una descripción más detallada
      
      // Encontrar el punto medio para el icono
      const midpointIndex = Math.floor(street.coordinates.length / 2);
      const iconPosition = street.coordinates[midpointIndex];
      
      // Crear el badge para el tipo de cambio
      let badgeClass = '';
      let badgeText = '';
      
      if (street.type === 'change') {
        badgeClass = 'street-badge change';
        badgeText = 'Cambio de sentido';
      } else if (street.type === 'doubleway') {
        badgeClass = 'street-badge doubleway';
        badgeText = 'Doble sentido';
      } else if (street.type === 'noparking') {
        badgeClass = 'street-badge noparking';
        badgeText = 'Prohibido estacionar';
      }
      
      // Crear un icono clickeable con el color según el tipo
      const streetIcon = L.divIcon({
        html: `<div class="street-icon ${street.type}"><span class="icon-tooltip">${street.name}</span></div>`,
        className: 'street-icon-container',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      });
      
      const streetMarker = L.marker(iconPosition, {
        icon: streetIcon,
        interactive: true,
        zIndexOffset: 1000
      }).addTo(map);
      
      // Definir estilos inline para el badge según el tipo
      let badgeStyle = '';
      if (street.type === 'change') {
        badgeStyle = 'display:inline-block;padding: 0.25rem 0.5rem;border-radius:.5em;color:white;font-size:12px;font-weight:bold;margin-bottom:8px;background-color:#1E88E5;';
      } else if (street.type === 'doubleway') {
        badgeStyle = 'display:inline-block;padding: 0.25rem 0.5rem;border-radius:.5em;color:white;font-size:12px;font-weight:bold;margin-bottom:8px;background-color:#27ae60;';
      } else if (street.type === 'noparking') {
        badgeStyle = 'display:inline-block;padding: 0.25rem 0.5rem;border-radius:.5em;color:white;font-size:12px;font-weight:bold;margin-bottom:8px;background-color:#e74c3c;';
      }
      
      // Mostrar la dirección proporcionada por el JSON si está disponible
      const sentidoLine = street.newDirection ? `<p><strong>Sentido:</strong> ${street.newDirection}</p>` : '';
      
      // Crear un popup mejorado con badges usando estilos inline
      const popupContentEnhanced = `
        <div class="street-popup">
          <span style="${badgeStyle}">${badgeText}</span>
          <h3 style="font-size:18px;margin:5px 0;font-weight:600;">${street.name}</h3>
          <p style="margin:5px 0;font-size:16px;"><strong>Tramo:</strong> ${street.section}</p>
          ${sentidoLine}
          ${street.details ? `<p style="margin:5px 0;font-size:16px;">${street.details}</p>` : ''}
        </div>
      `;
      
      // Asignar este popup mejorado al marcador y a las líneas
      streetMarker.bindPopup(popupContentEnhanced);
      streetPath.bindPopup(popupContentEnhanced);
      clickablePath.bindPopup(popupContentEnhanced);
      
      // Agregar flechas de dirección usando PolylineDecorator
      if (street.direction && street.direction !== 'none' || street.type === 'doubleway') {
        // Debug para verificar todos los tipos de calles y direcciones
        console.log(`Procesando calle: ${street.name}, tipo: ${street.type}, dirección: ${street.direction}`);
        
        // Mostrar explícitamente si la calle califica para flechas bidireccionales
        const isBidirectional = street.type === 'doubleway' || street.direction === 'norte-sur' || street.direction === 'este-oeste';
        console.log(`¿Es bidireccional? ${isBidirectional ? 'SÍ' : 'NO'}`);
        
        // Determinar la dirección de las flechas según el tipo de cambio
        if (street.type === 'doubleway' || street.direction === 'norte-sur' || street.direction === 'este-oeste') {
          // Para calles de doble sentido, usamos un estilo diferente
          if (street.type === 'doubleway') {
            // Solo usar línea punteada para doble sentido, SIN flechas
            streetPath.setStyle({
              dashArray: '10, 10',  // Patrón de línea punteada
              weight: 8,  // Hacer la línea más gruesa
            });
            
            // No aplicar flechas para calles de doble sentido
            pattern = []; // Patrón vacío, no se mostrarán flechas
            console.log('Calle de doble sentido - usando solo línea punteada sin flechas:', street.name);
          } else {
            // Para otras direcciones bidireccionales (norte-sur o este-oeste)
            console.log(`Aplicando flechas bidireccionales para: ${street.name}, dirección: ${street.direction}`);
            
            // Usar estilo dashed también para mayor claridad en bidireccionales
            streetPath.setStyle({
              dashArray: '5, 10',  // Patrón de línea punteada más sutil
              weight: 6,  // Hacer la línea más gruesa
            });
            
            pattern = [
              { offset: '30%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 18, pathOptions: { color: streetColor, fillOpacity: 1, weight: 3 } }) },
              { offset: '70%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 18, pathOptions: { color: streetColor, fillOpacity: 1, weight: 3 }, heading: 180 }) }
            ];
          }
        } else {
          // Flecha simple para un solo sentido
          pattern = [
            { offset: '25%', repeat: '50px', symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 } }) }
          ];
        }
        
        // Solo agregar flechas si hay un patrón definido (no para calles tipo 'doubleway')
        if (pattern.length > 0) {
          // Agregar las flechas pero asegurándonos que no interfieran con los clics
          const decorator = L.polylineDecorator(streetPath, {
            patterns: pattern,
            interactive: false, // Evitar que las flechas capturen eventos de clic
            zIndex: 1000, // Asegurar que las flechas aparezcan encima de todas las capas
            opacity: 1.0,
            weight: 2
          }).addTo(map);
          
          // Asegurarse de que el decorador está en la capa correcta y visible
          console.log(`Decorador creado para ${street.name}:`, decorator);
        } else {
          console.log(`Sin decorador para calle de doble vía ${street.name} - solo estilo de línea`);
        }
      }
    });
    
    // Verificar qué tipos existen en los datos
    checkExistingTypes();
    
    // Actualizar la leyenda inicialmente
    updateLegendVisibility();
    
    // Ocultar inmediatamente los tipos que no existen en los datos
    if (!existingTypes.change) document.getElementById('change-legend-item').classList.add('hidden');
    if (!existingTypes.doubleway) document.getElementById('doubleway-legend-item').classList.add('hidden');
    if (!existingTypes.noparking) document.getElementById('noparking-legend-item').classList.add('hidden');
    if (!existingTypes.hasArrows) document.getElementById('direction-legend-item').classList.add('hidden');
  });
</script>

<style>
  .map-container {
    position: relative;
    width: 100%;
    margin: 0;
    border-radius: var(--radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }
  
  .map {
    height: 500px;
    width: 100%;
    z-index: 1;
  }
  
  .map-legend {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color: white;
    padding: 10px 15px;
    border-radius: var(--radius);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 10;
  }
  
  .legend-item.hidden {
    display: none;
  }
  
  .map-legend h4 {
    margin-bottom: 10px;
    font-size: 14px;
    font-weight: 600;
    color: var(--accent-dark);
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
  }
  
  .legend-color {
    display: inline-block;
    width: 16px;
    height: 4px;
    margin-right: 8px;
    border-radius: 2px;
  }
  
  .legend-color.change-direction {
    background-color: #1E88E5;
  }
  
  .legend-color.double-way {
    background-color: #27ae60;
  }
  
  .legend-color.no-parking {
    background-color: #e74c3c;
  }
  
  .legend-icon {
    font-size: 18px;
    margin-right: 8px;
    color: var(--accent-dark);
  }
  
  .street-icon-container {
    background: none !important;
  }
  
  .street-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    position: relative;
    cursor: pointer;
    z-index: 1000;
  }
  
  .street-icon.change {
    background-color: #1E88E5;
  }
  
  .street-icon.doubleway {
    background-color: #27ae60;
  }
  
  .street-icon.noparking {
    background-color: #e74c3c;
  }
  
  :global(.icon-tooltip) {
    background-color: rgba(0, 0, 0, 0.8);
    color: #fff;
    text-align: center;
    border-radius: 4px;
    padding: 4px 8px;
    position: absolute;
    z-index: 1001;
    bottom: 125%;
    left: 50%;
    margin-left: -60px;
    opacity: 0;
    transition: opacity 0.3s;
    width: 120px;
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  :global(.street-icon:hover .icon-tooltip) {
    visibility: visible;
    opacity: 1;
  }
  
  /* Estilos para los badges en los popups */
  :global(.street-badge) {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 4px;
    color: white;
    font-size: 12px;
    font-weight: bold;
    margin-bottom: 8px;
  }
  
  :global(.street-badge.change) {
    background-color: #1E88E5;
  }
  
  :global(.street-badge.doubleway) {
    background-color: #27ae60;
  }
  
  :global(.street-badge.noparking) {
    background-color: #e74c3c;
  }
  
  /* Estilos para el popup */
  :global(.street-popup h3) {
    color: var(--accent-dark);
    font-size: 20px;
    margin-bottom: 10px !important;
    font-weight: 600;
    font-family: 'Source Sans 3', system-ui, sans-serif;
  }
  
  :global(.street-popup p) {
    margin: 10px 0 !important;
    font-size: 16px;
    line-height: 1.4;
    font-family: 'Source Sans 3', system-ui, sans-serif;
  }

  :global(.street-popup) {
    font-family: 'Source Sans 3', system-ui, sans-serif;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .map {
      height: 450px; /* Increased height for mobile */
    }
    
    .map-legend {
      bottom: 10px;
      right: 10px;
      padding: 8px 10px;
      font-size: 12px;
    }
    
    .legend-color {
      width: 12px;
      height: 3px;
    }
  }
</style>
