---
export interface Props {
  mapId: string;
  locationName: string;
  centerLat: number;
  centerLng: number;
  initialZoom: number;
  mapData: any;
}

const { mapId, locationName, centerLat, centerLng, initialZoom, mapData } = Astro.props;
---

<div class="map-container">
  <div id={mapId} class="map"></div>
  <div class="map-legend">
    <h4>Cambios de sentido en {locationName}</h4>
    <div class="legend-item">
      <span class="legend-color change-direction"></span>
      <span>Cambio de sentido</span>
    </div>
    <div class="legend-item">
      <span class="legend-color double-way"></span>
      <span>Doble sentido</span>
    </div>
    <div class="legend-item">
      <span class="legend-color no-parking"></span>
      <span>Prohibido estacionar</span>
    </div>
    <div class="legend-item">
      <span class="legend-icon">↑</span>
      <span>Dirección de circulación</span>
    </div>
  </div>
</div>

<script define:vars={{ mapId, centerLat, centerLng, initialZoom, mapData }}>
  // Importar Leaflet solo en el lado del cliente
  document.addEventListener('DOMContentLoaded', async () => {
    // Cargar dinamicamente Leaflet desde CDN si no está ya cargado
    if (!window.L) {
      await new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        script.onload = resolve;
        document.head.appendChild(script);

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        document.head.appendChild(link);
      });
    }
    
    // Cargar Leaflet.PolylineDecorator para las flechas
    await new Promise((resolve) => {
      const polylineDecoratorScript = document.createElement('script');
      polylineDecoratorScript.src = 'https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js';
      polylineDecoratorScript.onload = resolve;
      document.head.appendChild(polylineDecoratorScript);
    });
    
    // Inicializar el mapa
    const map = L.map(mapId).setView([centerLat, centerLng], initialZoom);
    
    // Agregar la capa base de OpenStreetMap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 19
    }).addTo(map);
    
    // Determinar la dirección de las flechas según el tipo de cambio
    function determineDirection(direction, type) {
      if (type === 'doubleway') {
        return 'bidirectional';
      } else if (direction === 'none') {
        return 'none';
      } else {
        return direction;
      }
    }
    
    // Determinar el color según el tipo de cambio
    function getStreetColor(type) {
      switch(type) {
        case 'change': return '#1E88E5';
        case 'doubleway': return '#27ae60';
        case 'noparking': return '#e74c3c';
        default: return '#FF8A65';
      }
    }
    
    // Agregar líneas para las calles con cambios
    mapData.forEach(street => {
      // Obtener el color basado en el tipo de calle
      const streetColor = getStreetColor(street.type);
      
      // Crear una capa invisible más ancha para facilitar el clic
      const clickablePath = L.polyline(street.coordinates, {
        color: 'transparent',
        weight: 12, // El doble de ancho pero invisible
        opacity: 0
      }).addTo(map);
      
      // Crear la línea visible para la calle
      const streetPath = L.polyline(street.coordinates, {
        color: streetColor,
        weight: 6,
        opacity: 0.8
      }).addTo(map);
      
      // Preparar texto para el popup con mejor descripción del sentido
      let sentidoTexto = '';
      if (street.type === 'change') {
        sentidoTexto = 'Cambió de sentido: ahora circulación en un solo sentido';
      } else if (street.type === 'doubleway') {
        sentidoTexto = 'Mantiene doble sentido de circulación';
      } else if (street.type === 'noparking') {
        sentidoTexto = 'Prohibido estacionar';
      }
      
      // Agregar popup con información mejorada a ambas capas
      const popupContent = `
        <div class="street-popup">
          <h3>${street.name}</h3>
          <p><strong>Tramo:</strong> ${street.section}</p>
          <p><strong>Sentido:</strong> ${sentidoTexto}</p>
          ${street.details ? `<p>${street.details}</p>` : ''}
        </div>
      `;
      
      // Aplicar el popup a la línea visible
      streetPath.bindPopup(popupContent);
      
      // Aplicar el popup también a la capa clickeable invisible
      clickablePath.bindPopup(popupContent);
      
      // Añadir etiqueta visible en el mapa
      const midpointIndex = Math.floor(street.coordinates.length / 2);
      const labelPosition = street.coordinates[midpointIndex];
      
      // Crear la etiqueta que también es clickeable
      const streetLabel = L.marker(labelPosition, {
        icon: L.divIcon({
          html: `<div class="street-label">${street.name}</div>`,
          className: 'street-label-container',
          iconSize: [180, 30],
          iconAnchor: [90, 15]
        }),
        interactive: true,  // Hacer la etiqueta interactiva
        zIndexOffset: 1000  // Asegurar que está por encima de otras capas
      }).addTo(map);
      
      // Vincular el mismo popup a la etiqueta
      streetLabel.bindPopup(popupContent);
      
      // Agregar flechas de dirección usando PolylineDecorator
      if (street.direction && street.direction !== 'none') {
        let pattern;
        
        if (street.type === 'doubleway' || street.direction === 'norte-sur' || street.direction === 'este-oeste') {
          // Doble flecha para doble sentido
          pattern = [
            { offset: '25%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 } }) },
            { offset: '75%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 }, heading: -180 }) }
          ];
        } else {
          // Flecha simple para un solo sentido
          pattern = [
            { offset: '25%', repeat: '50px', symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 } }) }
          ];
        }
        
        // Agregar las flechas pero asegurándonos que no interfieran con los clics
        const decorator = L.polylineDecorator(streetPath, {
          patterns: pattern,
          interactive: false // Evitar que las flechas capturen eventos de clic
        }).addTo(map);
      }
    });
  });
</script>

<style>
  .map-container {
    position: relative;
    width: 100%;
    margin: 2rem 0;
    border-radius: var(--radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }
  
  .map {
    height: 500px;
    width: 100%;
    z-index: 1;
  }
  
  .map-legend {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color: white;
    padding: 10px 15px;
    border-radius: var(--radius);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 500;
  }
  
  .map-legend h4 {
    margin-bottom: 10px;
    font-size: 14px;
    font-weight: 600;
    color: var(--accent-dark);
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
  }
  
  .legend-color {
    display: inline-block;
    width: 16px;
    height: 4px;
    margin-right: 8px;
    border-radius: 2px;
  }
  
  .legend-color.change-direction {
    background-color: #1E88E5;
  }
  
  .legend-color.double-way {
    background-color: #27ae60;
  }
  
  .legend-color.no-parking {
    background-color: #e74c3c;
  }
  
  .legend-icon {
    font-size: 18px;
    margin-right: 8px;
    color: var(--accent-dark);
  }
  
  .street-label-container {
    background: none !important;
  }
  
  .street-label {
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 14px;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    z-index: 900;
    border: 2px solid white;
    cursor: pointer;
  }
  
  /* Estilos para el popup */
  :global(.street-popup h3) {
    color: var(--accent-dark);
    font-size: 16px;
    margin-bottom: 5px;
    font-weight: 600;
  }
  
  :global(.street-popup p) {
    margin: 5px 0;
    font-size: 14px;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .map {
      height: 400px;
    }
    
    .map-legend {
      bottom: 10px;
      right: 10px;
      padding: 8px 10px;
      font-size: 12px;
    }
    
    .legend-color {
      width: 12px;
      height: 3px;
    }
  }
</style>
