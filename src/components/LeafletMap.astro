---
export interface Props {
  mapId: string;
  locationName: string;
  centerLat: number;
  centerLng: number;
  initialZoom: number;
  mapData: any;
}

const { mapId, locationName, centerLat, centerLng, initialZoom, mapData } = Astro.props;
---

<div class="map-container">
  <div id={mapId} class="map"></div>
  <div class="map-legend">
    <h4>Cambios de sentido en {locationName}</h4>
    <div class="legend-item">
      <span class="legend-color change-direction"></span>
      <span>Cambio de sentido</span>
    </div>
    <div class="legend-item">
      <span class="legend-color double-way"></span>
      <span>Doble sentido</span>
    </div>
    <div class="legend-item">
      <span class="legend-color no-parking"></span>
      <span>Prohibido estacionar</span>
    </div>
    <div class="legend-item">
      <span class="legend-icon">↑</span>
      <span>Dirección de circulación</span>
    </div>
  </div>
</div>

<script define:vars={{ mapId, centerLat, centerLng, initialZoom, mapData }}>
  // Importar Leaflet solo en el lado del cliente
  document.addEventListener('DOMContentLoaded', async () => {
    // Cargar dinamicamente Leaflet desde CDN si no está ya cargado
    if (!window.L) {
      await new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        script.onload = resolve;
        document.head.appendChild(script);

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        document.head.appendChild(link);
      });
    }
    
    // Cargar Leaflet.PolylineDecorator para las flechas
    await new Promise((resolve) => {
      const polylineDecoratorScript = document.createElement('script');
      polylineDecoratorScript.src = 'https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js';
      polylineDecoratorScript.onload = resolve;
      document.head.appendChild(polylineDecoratorScript);
    });
    
    // Inicializar el mapa
    const map = L.map(mapId).setView([centerLat, centerLng], initialZoom);
    
    // Agregar la capa base de OpenStreetMap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 19
    }).addTo(map);
    
    // Determinar la dirección de las flechas según el tipo de cambio
    function determineDirection(direction, type) {
      if (type === 'doubleway') {
        return 'bidirectional';
      } else if (direction === 'none') {
        return 'none';
      } else {
        return direction;
      }
    }
    
    // Determinar el color según el tipo de cambio
    function getStreetColor(type) {
      switch(type) {
        case 'change': return '#1E88E5';
        case 'doubleway': return '#27ae60';
        case 'noparking': return '#e74c3c';
        default: return '#FF8A65';
      }
    }
    // Asegurarnos que mapData sea un array válido
    const streetData = Array.isArray(mapData) ? mapData : [];
    // Agregar líneas para las calles con cambios
    streetData.forEach(street => {
      // Obtener el color basado en el tipo de calle
      const streetColor = getStreetColor(street.type);
      
      // Crear una capa invisible más ancha para facilitar el clic
      const clickablePath = L.polyline(street.coordinates, {
        color: 'transparent',
        weight: 12, // El doble de ancho pero invisible
        opacity: 0
      }).addTo(map);
      
      // Crear la línea visible para la calle
      const streetPath = L.polyline(street.coordinates, {
        color: streetColor,
        weight: 6,
        opacity: 0.8
      }).addTo(map);
      
      // Preparar texto para el popup con mejor descripción del sentido
      let sentidoTexto = '';
      if (street.type === 'change') {
        sentidoTexto = 'Cambió de sentido: ahora circulación en un solo sentido';
      } else if (street.type === 'doubleway') {
        sentidoTexto = 'Mantiene doble sentido de circulación';
      } else if (street.type === 'noparking') {
        sentidoTexto = 'Prohibido estacionar';
      }
      
      // Agregar popup con información mejorada a ambas capas
      const popupContent = `
        <div class="street-popup">
          <h3>${street.name}</h3>
          <p><strong>Tramo:</strong> ${street.section}</p>
          <p><strong>Sentido:</strong> ${sentidoTexto}</p>
          ${street.details ? `<p>${street.details}</p>` : ''}
        </div>
      `;
      
      // Ahora usaremos el popup mejorado que crearemos más adelante
      // Primero, extraemos las calles y creamos una descripción más detallada
      
      // Encontrar el punto medio para el icono
      const midpointIndex = Math.floor(street.coordinates.length / 2);
      const iconPosition = street.coordinates[midpointIndex];
      
      // Extraer las calles de la descripción del tramo
      const sectionParts = street.section.split(' ');
      let calle1 = '', calle2 = '';
      
      // Intentar identificar las calles mencionadas en la descripción
      if (street.section.toLowerCase().includes('entre')) {
        const entreIndex = sectionParts.findIndex(word => word.toLowerCase() === 'entre');
        if (entreIndex !== -1 && entreIndex + 1 < sectionParts.length) {
          calle1 = sectionParts[entreIndex + 1];
          // Buscar la segunda calle después de 'y'
          const yIndex = sectionParts.findIndex((word, index) => index > entreIndex && (word.toLowerCase() === 'y' || word.toLowerCase() === 'e'));
          if (yIndex !== -1 && yIndex + 1 < sectionParts.length) {
            calle2 = sectionParts[yIndex + 1];
          }
        }
      } else if (street.section.toLowerCase().includes('desde') || street.section.toLowerCase().includes('de')) {
        const desdeIndex = sectionParts.findIndex(word => 
          word.toLowerCase() === 'desde' || word.toLowerCase() === 'de');
        if (desdeIndex !== -1 && desdeIndex + 1 < sectionParts.length) {
          calle1 = sectionParts[desdeIndex + 1];
          // Buscar la segunda calle después de 'hasta' o 'a'
          const hastaIndex = sectionParts.findIndex((word, index) => 
            index > desdeIndex && (word.toLowerCase() === 'hasta' || word.toLowerCase() === 'a'));
          if (hastaIndex !== -1 && hastaIndex + 1 < sectionParts.length) {
            calle2 = sectionParts[hastaIndex + 1];
          }
        }
      }
      
      // Si no se pudo identificar, usar valores genéricos
      if (!calle1) calle1 = 'primera calle';
      if (!calle2) calle2 = 'segunda calle';
      
      // Crear un texto descriptivo más claro para el sentido
      let sentidoDetallado = '';
      if (street.type === 'change') {
        sentidoDetallado = `de ${calle1} hacia ${calle2}. Ahora circulación en un solo sentido`;
      } else if (street.type === 'doubleway') {
        sentidoDetallado = `Doble sentido entre ${calle1} y ${calle2}`;
      } else if (street.type === 'noparking') {
        sentidoDetallado = `Prohibido estacionar entre ${calle1} y ${calle2}`;
      }
      
      // Crear el badge para el tipo de cambio
      let badgeClass = '';
      let badgeText = '';
      
      if (street.type === 'change') {
        badgeClass = 'street-badge change';
        badgeText = 'Cambio de sentido';
      } else if (street.type === 'doubleway') {
        badgeClass = 'street-badge doubleway';
        badgeText = 'Doble sentido';
      } else if (street.type === 'noparking') {
        badgeClass = 'street-badge noparking';
        badgeText = 'Prohibido estacionar';
      }
      
      // Crear un icono clickeable con el color según el tipo
      const streetIcon = L.divIcon({
        html: `<div class="street-icon ${street.type}"><span class="icon-tooltip">${street.name}</span></div>`,
        className: 'street-icon-container',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      });
      
      const streetMarker = L.marker(iconPosition, {
        icon: streetIcon,
        interactive: true,
        zIndexOffset: 1000
      }).addTo(map);
      
      // Definir estilos inline para el badge según el tipo
      let badgeStyle = '';
      if (street.type === 'change') {
        badgeStyle = 'display:inline-block;padding: 0.25rem 0.5rem;border-radius:.5em;color:white;font-size:12px;font-weight:bold;margin-bottom:8px;background-color:#1E88E5;';
      } else if (street.type === 'doubleway') {
        badgeStyle = 'display:inline-block;padding: 0.25rem 0.5rem;border-radius:.5em;color:white;font-size:12px;font-weight:bold;margin-bottom:8px;background-color:#27ae60;';
      } else if (street.type === 'noparking') {
        badgeStyle = 'display:inline-block;padding: 0.25rem 0.5rem;border-radius:.5em;color:white;font-size:12px;font-weight:bold;margin-bottom:8px;background-color:#e74c3c;';
      }
      
      // Determinar si mostrar o no la línea de sentido (no mostrar para prohibido estacionar)
      const sentidoLine = street.type === 'noparking' ? '' : `<p><strong>Sentido:</strong> ${sentidoDetallado}</p>`;
      
      // Crear un popup mejorado con badges usando estilos inline
      const popupContentEnhanced = `
        <div class="street-popup">
          <span style="${badgeStyle}">${badgeText}</span>
          <h3 style="font-size:18px;margin:5px 0;font-weight:600;">${street.name}</h3>
          <p style="margin:5px 0;font-size:16px;"><strong>Tramo:</strong> ${street.section}</p>
          ${sentidoLine}
          ${street.details ? `<p style="margin:5px 0;font-size:16px;">${street.details}</p>` : ''}
        </div>
      `;
      
      // Asignar este popup mejorado al marcador y a las líneas
      streetMarker.bindPopup(popupContentEnhanced);
      streetPath.bindPopup(popupContentEnhanced);
      clickablePath.bindPopup(popupContentEnhanced);
      
      // Agregar flechas de dirección usando PolylineDecorator
      if (street.direction && street.direction !== 'none') {
        let pattern;
        
        if (street.type === 'doubleway' || street.direction === 'norte-sur' || street.direction === 'este-oeste') {
          // Para calles de doble sentido, usamos un estilo diferente
          if (street.type === 'doubleway') {
            // Usar línea punteada para doble sentido en lugar de flechas
            streetPath.setStyle({
              dashArray: '10, 10',  // Patrón de línea punteada
              weight: 8,  // Hacer la línea más gruesa
            });
            
            // Agregar dos flechas opuestas en el centro
            pattern = [
              { offset: '40%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 18, pathOptions: { color: streetColor, fillOpacity: 1, weight: 3 } }) },
              { offset: '60%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 18, pathOptions: { color: streetColor, fillOpacity: 1, weight: 3 }, heading: -180 }) }
            ];
          } else {
            // Para otras direcciones bidireccionales
            pattern = [
              { offset: '25%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 } }) },
              { offset: '75%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 }, heading: -180 }) }
            ];
          }
        } else {
          // Flecha simple para un solo sentido
          pattern = [
            { offset: '25%', repeat: '50px', symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { color: streetColor, fillOpacity: 1, weight: 2 } }) }
          ];
        }
        
        // Agregar las flechas pero asegurándonos que no interfieran con los clics
        const decorator = L.polylineDecorator(streetPath, {
          patterns: pattern,
          interactive: false // Evitar que las flechas capturen eventos de clic
        }).addTo(map);
      }
    });
  });
</script>

<style>
  .map-container {
    position: relative;
    width: 100%;
    margin: 2rem 0;
    border-radius: var(--radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }
  
  .map {
    height: 500px;
    width: 100%;
    z-index: 1;
  }
  
  .map-legend {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color: white;
    padding: 10px 15px;
    border-radius: var(--radius);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 500;
  }
  
  .map-legend h4 {
    margin-bottom: 10px;
    font-size: 14px;
    font-weight: 600;
    color: var(--accent-dark);
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
  }
  
  .legend-color {
    display: inline-block;
    width: 16px;
    height: 4px;
    margin-right: 8px;
    border-radius: 2px;
  }
  
  .legend-color.change-direction {
    background-color: #1E88E5;
  }
  
  .legend-color.double-way {
    background-color: #27ae60;
  }
  
  .legend-color.no-parking {
    background-color: #e74c3c;
  }
  
  .legend-icon {
    font-size: 18px;
    margin-right: 8px;
    color: var(--accent-dark);
  }
  
  .street-icon-container {
    background: none !important;
  }
  
  .street-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    position: relative;
    cursor: pointer;
    z-index: 1000;
  }
  
  .street-icon.change {
    background-color: #1E88E5;
  }
  
  .street-icon.doubleway {
    background-color: #27ae60;
  }
  
  .street-icon.noparking {
    background-color: #e74c3c;
  }
  
  :global(.icon-tooltip) {
    display: inline-block;
    padding: 0.25rem 0.5rem;
    border-radius: .5em;
    color: white;
    font-size: 12px;
    font-weight: bold;
    margin-bottom: 8px;
    background-color: #1E88E5;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }
  
  :global(.street-icon:hover .icon-tooltip) {
    visibility: visible;
    opacity: 1;
  }
  
  /* Estilos para los badges en los popups */
  :global(.street-badge) {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 4px;
    color: white;
    font-size: 12px;
    font-weight: bold;
    margin-bottom: 8px;
  }
  
  :global(.street-badge.change) {
    background-color: #1E88E5;
  }
  
  :global(.street-badge.doubleway) {
    background-color: #27ae60;
  }
  
  :global(.street-badge.noparking) {
    background-color: #e74c3c;
  }
  
  /* Estilos para el popup */
  :global(.street-popup h3) {
    color: var(--accent-dark);
    font-size: 20px;
    margin-bottom: 10px !important;
    font-weight: 600;
    font-family: 'Source Sans 3', system-ui, sans-serif;
  }
  
  :global(.street-popup p) {
    margin: 10px 0 !important;
    font-size: 16px;
    line-height: 1.4;
    font-family: 'Source Sans 3', system-ui, sans-serif;
  }

  :global(.street-popup) {
    font-family: 'Source Sans 3', system-ui, sans-serif;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .map {
      height: 400px;
    }
    
    .map-legend {
      bottom: 10px;
      right: 10px;
      padding: 8px 10px;
      font-size: 12px;
    }
    
    .legend-color {
      width: 12px;
      height: 3px;
    }
  }
</style>
